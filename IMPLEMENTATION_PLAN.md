# Implementation Plan — clawdex

> Solana DEX trading CLI routing swaps through Jupiter with integrator fee collection, agent-safe JSON mode, transaction simulation/transparency, receipt logging, and configurable safety guardrails.

## Phase 1: Project Scaffolding

- [x] Create `package.json` with name `clawdex`, bin entry pointing to `src/cli.ts`, all dependencies (`@solana/web3.js ^1.98`, `@solana/spl-token ^0.4`, `commander ^13`, `@iarna/toml ^2.2`, `chalk ^5`) and devDependencies (`typescript ^5.7`, `@types/bun`, `eslint ^9`, `@typescript-eslint/eslint-plugin ^8`, `@typescript-eslint/parser ^8`). Run `bun install` successfully.
- [x] Create `tsconfig.json` targeting ESNext, module ESNext, moduleResolution bundler, strict mode, outDir `dist/`, include `src/**/*` and `tests/**/*`.
- [x] Create `eslint.config.mjs` with TypeScript ESLint flat config for strict linting.
- [x] Create `.gitignore` with entries for `node_modules/`, `dist/`, `*.env`, `.env*`, `bun.lockb`.
- [x] Create the full directory structure: `src/commands/`, `src/core/`, `tests/commands/`, `tests/core/`, `tests/fixtures/`. Create a minimal `src/cli.ts` entry point that imports commander, sets name/version/description, configures `program.showHelpAfterError(true)` and rejects unknown options (Commander's `allowUnknownOption` must NOT be set), and calls `program.parse()`. Verify `bun run src/cli.ts --help` prints output and `bun x tsc --noEmit` passes.

## Phase 2: Types and Constants

- [x] Create `src/types.ts` with all shared type definitions: `ClawdexConfig` (rpc, wallet, fee_bps, fee_account, receipts_dir, safety section), `SafetyConfig` (max_fee_bps, max_slippage_bps, max_price_impact_bps, max_trade_sol, allowlist, rpc_allowlist), `QuoteResult`, `SwapResult`, `TransferDiff` (sol_change, token_changes, destinations, fees), `Receipt`, `TokenInfo` (mint, symbol, decimals), `OutputMode` enum (Human/JSON), exit code constants, and the pluggable `Signer` interface (sign method accepting `VersionedTransaction`, returning signed `VersionedTransaction` — Jupiter v1 API returns versioned transactions). Note: `KeypairSigner` implementing this interface will be built in Phase 3 with `wallet.ts`.
- [x] Create `src/constants.ts` with: known program IDs (System Program, Token Program, ATA Program, Jupiter v6 on-chain program `JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4`), well-known token mints (SOL/wSOL `So11111111111111111111111111111111111111112`, USDC `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`, USDT `Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB`), default config values, Jupiter REST API v1 base URLs (`https://api.jup.ag/swap/v1/quote`, `https://api.jup.ag/swap/v1/swap`), Jupiter token list URL (`https://tokens.jup.ag/tokens?tags=verified`), config file path (`~/.clawdex/config.toml`), default receipts dir (`~/.clawdex/receipts`), exit code numeric constants (0=success, 1=general, 2=safety, 3=simulation, 4=send/confirm, 5=config), and structured error code strings (`SAFETY_CHECK_FAILED`, `SIMULATION_FAILED`, `UNKNOWN_TRANSFER`, `SLIPPAGE_EXCEEDED`, `PRICE_IMPACT_EXCEEDED`, `MAX_TRADE_EXCEEDED`, `ALLOWLIST_REJECTED`, `RPC_NOT_ALLOWED`, `INSUFFICIENT_BALANCE`, `CONFIG_ERROR`, `FEE_EXCEEDED`). Note: clearly distinguish Jupiter REST API version (v1) from Jupiter on-chain program version (v6).

## Phase 3: Core Modules — Foundation Layer

- [x] Implement `src/core/config.ts`: parse TOML config from `~/.clawdex/config.toml`, create config dir and default config if missing, implement config layering (defaults < file < env vars `CLAWDEX_*` < CLI flags), validate all values on load (valid pubkeys, valid URLs, numeric ranges). Enforce `rpc_allowlist` at config-load time: if `rpc_allowlist` is non-empty and the resolved RPC URL is not in the list, reject with `RPC_NOT_ALLOWED` error immediately (not deferred to swap-time safety checks). Expose `loadConfig()` and `resolveConfig(cliOverrides)` functions. Implement `setConfigValue(key, value)` and `setSafetyValue(key, value)` that read-modify-write the TOML file preserving structure.
- [x] Implement `src/core/wallet.ts`: load keypair from JSON file path using `Keypair.fromSecretKey`, expand `~` in paths, validate file exists and contains valid keypair bytes, expose `loadWallet(path): Keypair`. Implement the `Signer` interface defined in `types.ts` with a `KeypairSigner` class that wraps a loaded keypair and signs `VersionedTransaction` objects. Return clear errors for missing file, invalid format, etc.
- [x] Implement `src/core/tokens.ts`: hardcoded map for SOL/USDC/USDT symbol-to-mint, fetch Jupiter verified token list from `https://tokens.jup.ag/tokens?tags=verified` with 1-hour TTL cache — use **file-based cache** (write to `~/.clawdex/token-cache.json` with timestamp) so the cache persists across CLI invocations (an in-memory cache is useless for a CLI since each invocation is a fresh process). Resolve symbol or mint address input to `TokenInfo` (mint, symbol, decimals), handle raw mint address passthrough, expose `resolveToken(input: string): Promise<TokenInfo>`. Return clear error for unresolvable tokens.
- [x] Implement `src/core/output.ts`: unified output helper that formats results for human-readable (chalk-colored tables/summaries) or JSON mode (stable, parseable JSON on stdout, errors on stderr). Expose `formatOutput(data, mode)`, `formatError(error, mode)`, `printResult(data, options)`, and `printError(error, options)`. Human mode should use chalk for status indicators (green/red), alignment for key-value pairs, and table-like formatting for routes/balances. JSON mode outputs `JSON.stringify` with 2-space indent.

## Phase 4: Core Modules — Integration Layer

- [x] Implement `src/core/jupiter.ts`: Jupiter API client with `getQuote(params)` (GET `https://api.jup.ag/swap/v1/quote` with inputMint, outputMint, amount in smallest unit, slippageBps, platformFeeBps — note `platformFeeBps: 0` is valid and means no fee), `getSwapTransaction(quoteResponse, userPublicKey, feeAccount)` (POST `https://api.jup.ag/swap/v1/swap` with `dynamicComputeUnitLimit: true`, `dynamicSlippage: true` if no explicit slippage), parse quote response into `QuoteResult` (including route venues/percentages, price impact, fee breakdown). Implement rate-limit handling (429 with exponential backoff, max 3 retries), stale quote detection, and clear error messages for API failures. Derive `feeAccount` ATA using `getAssociatedTokenAddress(outputMint, feeWallet)`. Check if the fee ATA exists on-chain and create it if missing (using `createAssociatedTokenAccountIdempotent` or equivalent) before submitting the swap — note that ATA creation costs ~0.002 SOL rent paid by the user's wallet and this cost must be reflected in the transfer diff. Include debug-level logging for all API requests/responses (controlled by `DEBUG=clawdex` env var using simple `console.error` when `process.env.DEBUG?.includes('clawdex')` — no logging framework needed).
- [x] Implement `src/core/safety.ts`: validate a proposed swap against safety config. Check `max_fee_bps`, `max_slippage_bps` (reject if requested slippage exceeds maximum), `max_price_impact_bps`, `max_trade_sol` (for SOL-equivalent estimation: if input is SOL/wSOL, use input amount directly; otherwise, treat the quote's `inAmount` as non-SOL and skip this check or use a secondary SOL quote for estimation — document the chosen approach), `allowlist` (output mint must be in list if list is non-empty). Note: `rpc_allowlist` is enforced at config-load time in `config.ts`, NOT here. Each check returns a specific error code and message (use distinct codes: `FEE_EXCEEDED`, `SLIPPAGE_EXCEEDED`, `PRICE_IMPACT_EXCEEDED`, `MAX_TRADE_EXCEEDED`, `ALLOWLIST_REJECTED`). Expose `validateSafety(quoteResult, config): SafetyCheckResult[]` where each result is pass/fail with reason. Fail closed: any failure rejects the swap.
- [x] Implement `src/core/simulate.ts`: simulate a versioned transaction via `connection.simulateTransaction()`, parse simulation result for success/failure, compute units consumed, log messages, and pre/post token balances. Compute `TransferDiff`: net SOL change, token balance changes (amounts with mints), all destination addresses for outgoing transfers, fee amounts. Classify addresses as known (user wallet, user ATAs, Jupiter v6 program ID, DEX program IDs extracted from the quote response's `routePlan` entries, fee ATA, System/Token/ATA programs) vs unknown. Expose `simulateAndDiff(transaction, connection, knownAddresses): SimulationResult`. Flag unknown destination addresses for rejection.
- [x] Implement `src/core/receipts.ts`: append-only JSONL receipt storage. Write receipts to `{receipts_dir}/receipts.jsonl`, one JSON object per line with all fields (timestamp ISO 8601, signature, input/output mint/symbol/amount, fee_bps/fee_amount/fee_token, route, slot, block_time, success, error). Expose `storeReceipt(receipt)` and `lookupReceipt(signature): Receipt | null` (scan JSONL for matching signature). Create receipts directory if missing.

## Phase 5: CLI Commands — Simple Commands

- [x] Implement `src/commands/config.ts`: `clawdex config set <key=value> [key=value ...]` command. Parse key=value pairs, validate keys against known config keys (rpc, fee_bps, fee_account, wallet, receipts_dir), validate values (pubkeys, URLs, numeric), call `setConfigValue()` for each. Support `--json` flag for output. Register with commander in `src/cli.ts` as a parent command `config` with subcommand `set`.
- [x] Implement `src/commands/safety.ts`: `clawdex safety set <key=value> [key=value ...]` command. Parse key=value pairs, validate keys against known safety keys (max_fee_bps, max_slippage_bps, max_price_impact_bps, max_trade_sol, allowlist, rpc_allowlist), validate values, call `setSafetyValue()` for each. Allowlist accepts comma-separated symbols/mints. Support `--json` flag. Register with commander in `src/cli.ts` as a parent command `safety` with subcommand `set`.
- [x] Implement `src/commands/status.ts`: `clawdex status` command. Check RPC connectivity (send `getSlot` RPC call, measure latency), check wallet config (configured? valid pubkey?), check fee_account config (configured? warn if missing), check token list availability (attempt fetch or use cache). Output human-readable status with green/red indicators or JSON `{ rpc, wallet, fee_account, token_list }`. Register with commander in `src/cli.ts`.

## Phase 6: CLI Commands — Data Commands

- [x] Implement `src/commands/balances.ts`: `clawdex balances [--wallet <path>]` command. Load wallet (from flag, config, or env), connect to RPC, fetch SOL balance via `getBalance()`, fetch token accounts via `getTokenAccountsByOwner()`, resolve token mints to symbols using token resolver. Output human-readable table or JSON `{ wallet, sol, tokens[] }`. Handle errors (wallet not configured, RPC unreachable). Register with commander in `src/cli.ts`.
- [x] Implement `src/commands/quote.ts`: `clawdex quote --in <TOKEN> --out <TOKEN> --amount <NUM>` command. Resolve input/output tokens, convert amount to smallest unit using decimals, call `jupiter.getQuote()` with slippage and fee params (from flags or config defaults), format and display quote result including route, price impact, fees. Support `--slippage-bps`, `--fee-bps`, `--json`. Register with commander in `src/cli.ts`.
- [x] Implement `src/commands/receipt.ts`: `clawdex receipt <txsig>` command. Call `lookupReceipt(signature)`, output the receipt JSON or error if not found. Support `--json` flag. Register with commander in `src/cli.ts`.

## Phase 7: CLI Command — Swap (Full Pipeline)

- [x] Implement `src/commands/swap.ts`: `clawdex swap --in <TOKEN> --out <TOKEN> --amount <NUM>` command orchestrating the full swap pipeline. Steps: (1) resolve tokens, (2) get quote from Jupiter with fee params (`--fee-bps 0` disables fees), (3) run safety checks against config, (4) build swap transaction via Jupiter API, (5) simulate transaction and compute transfer diff (unless `--skip-simulation`), (6) check for unknown destination addresses — fail closed (note: if `--skip-simulation` is used, this check is bypassed since it depends on simulation data; `--skip-simulation` is explicitly dangerous and should print/log a warning), (7) display transfer summary (human) or include in JSON, (8) if not `--yes`, prompt for confirmation (accept y/yes, reject n/no/EOF, handle non-TTY stdin by requiring `--yes`), (9) sign with wallet keypair via `KeypairSigner`, (10) send and confirm transaction, (11) store receipt, (12) output result. Store receipt for every swap attempt — including after safety check failures and simulation failures (with `success: false` and the error reason), not only after simulation passes. Support flags: `--slippage-bps`, `--fee-bps`, `--yes` (skip prompt), `--json`, `--simulate-only` (stop after simulate, output transfer diff — JSON output includes all fields except `signature`/`slot`/`block_time` which are null), `--skip-simulation` (bypass simulation, dangerous — warn in output). Use correct exit codes (0 success, 1 general error, 2 safety, 3 simulation, 4 send/confirm, 5 config). Register with commander in `src/cli.ts`.

## Phase 8: Tests

- [ ] Write tests for `src/core/config.ts`: test TOML parsing, config layering (defaults < file < env < flags), validation (reject invalid pubkeys, URLs, negative numbers), set operations (write and re-read), missing config file creation, `rpc_allowlist` enforcement at load time. Use temp directories for isolation.
- [ ] Write tests for `src/core/wallet.ts`: test keypair loading from valid file, error on missing file, error on invalid keypair data, `~` expansion, `KeypairSigner` wrapping and signing.
- [ ] Write tests for `src/core/tokens.ts`: test hardcoded SOL/USDC/USDT resolution, raw mint address passthrough, mock Jupiter token list fetch, file-based cache TTL behavior (stale cache triggers refetch, fresh cache skips fetch), error on unknown symbol.
- [ ] Write tests for `src/core/output.ts`: test human vs JSON mode output, error formatting, that JSON mode produces valid parseable JSON, that human mode includes color codes.
- [ ] Write tests for `src/core/jupiter.ts`: mock HTTP responses for quote and swap endpoints, test fee parameter inclusion (platformFeeBps in quote, feeAccount in swap), test rate-limit retry logic (mock 429 then success), test error handling for API failures, test ATA derivation for fee account.
- [ ] Write tests for `src/core/safety.ts`: test each safety check independently (max_fee_bps, max_slippage_bps, max_price_impact_bps, max_trade_sol, allowlist), test pass and fail cases, test that empty allowlist means "allow all", test fail-closed behavior, test that each check returns its specific error code.
- [ ] Write tests for `src/core/simulate.ts`: mock simulation responses with pre/post balances, test transfer diff computation (SOL changes, token changes), test known vs unknown address classification, test rejection on unknown destination.
- [ ] Write tests for `src/core/receipts.ts`: test JSONL append and lookup, test missing file/directory creation, test lookup of nonexistent signature returns null, test multiple receipts in single file.
- [ ] Write tests for CLI commands: test that each command registers correctly, parses flags, and calls the right core functions. Focus on argument parsing, `--json` flag behavior, exit codes, `--yes` flag (no prompts), and unknown flag rejection. Mock core modules to avoid real RPC/API calls. At minimum cover: config set, safety set, status, balances, quote, receipt, swap (with mocked pipeline including `--simulate-only` and `--skip-simulation` paths).

## Phase 9: Integration and Validation

- [ ] End-to-end validation: verify `bun install` succeeds, `bun run src/cli.ts --help` lists all 7 commands (status, balances, quote, swap, receipt, config, safety), `--help` works on each individual command and subcommand (`config set --help`, `safety set --help`), `bun x tsc --noEmit` passes with zero errors, `bun test` passes all tests, `bun run src/cli.ts config set rpc=https://api.mainnet-beta.solana.com` writes to config, `bun run src/cli.ts status` runs against configured RPC. Fix any issues found.
- [ ] Review all `--json` outputs for consistency: every command that supports `--json` outputs valid JSON to stdout and errors to stderr, exit codes match spec, error objects include `success: false` and `error` code with the correct specific error code string (not generic codes). Review all human outputs for readability and chalk coloring.
- [ ] Verify agent mode hardening: `--yes --json` combination works for swap (no prompts, structured errors on safety failures), all safety checks still enforced in agent mode, exit codes are correct for each failure type (2 for safety, 3 for simulation, 4 for send, 5 for config), non-TTY stdin without `--yes` fails gracefully with structured error.
